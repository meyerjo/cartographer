/*
 * Copyright 2016 The Cartographer Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "cartographer/io/pcd_ascii_intensity_writing_points_processor.h"

#include <iomanip>
#include <sstream>
#include <iostream>
#include <string>
#include <algorithm>

#include <Eigen/Dense>
#include <Eigen/Core>

#include "absl/memory/memory.h"
#include "cartographer/common/lua_parameter_dictionary.h"
#include "cartographer/io/points_batch.h"
#include "cartographer/common/time.h"
#include "glog/logging.h"

namespace cartographer {
namespace io {

namespace {


// Writes the PCD header claiming 'num_points' will follow it into
// 'output_file'.
// https://pointclouds.org/documentation/tutorials/pcd_file_format.html
void WriteBinaryPcdIntensityHeader(
    const bool has_color, const bool has_intensity, const bool has_reflectivity,
    const bool has_ambient, const bool has_range, const bool has_ring, const bool has_classification,
    const int64 num_points, FileWriter* const file_writer) {
  std::cerr << "has_color " << has_color << std::endl;
  std::cerr << "has_intensity " << has_intensity << std::endl;
  std::cerr << "has_reflectivity " << has_reflectivity << std::endl;
  std::cerr << "has_ambient " << has_ambient << std::endl;
  std::cerr << "has_range " << has_range << std::endl;
  std::cerr << "has_ring " << has_ring << std::endl;
  std::cerr << "has_classification " << has_classification << std::endl;


  std::string color_header_field = !has_color ? "" : " rgb red green blue";
  std::string color_header_type = !has_color ? "" : " U F F F";
  std::string color_header_size = !has_color ? "" : " 4 8 8 8";
  std::string color_header_count = !has_color ? "" : " 1 1 1 1";

  std::string intensity_header_field = !has_intensity ? "" : " intensity";
  std::string intensity_header_type = !has_intensity ? "" : " U";
  std::string intensity_header_size = !has_intensity ? "" : " 4";
  std::string intensity_header_count = !has_intensity ? "" : " 1";

  std::string reflectivity_header_field = !has_reflectivity ? "" : " reflectivity";
  std::string reflectivity_header_type = !has_reflectivity ? "" : " U";
  std::string reflectivity_header_size = !has_reflectivity ? "" : " 2";
  std::string reflectivity_header_count = !has_reflectivity ? "" : " 1";

  std::string ambient_header_field = !has_ambient ? "" : " ambient";
  std::string ambient_header_type = !has_ambient ? "" : " U";
  std::string ambient_header_size = !has_ambient ? "" : " 4";
  std::string ambient_header_count = !has_ambient ? "" : " 1";

  std::string range_header_field = !has_range ? "" : " range";
  std::string range_header_type = !has_range ? "" : " U";
  std::string range_header_size = !has_range ? "" : " 4";
  std::string range_header_count = !has_range ? "" : " 1";

  std::string ring_header_field = !has_ring ? "" : " ring";
  std::string ring_header_type = !has_ring ? "" : " U";
  std::string ring_header_size = !has_ring ? "" : " 4";
  std::string ring_header_count = !has_ring ? "" : " 1";

  std::string classification_header_field = !has_classification ? "" : " classification";
  std::string classification_header_type = !has_classification ? "" : " U";
  std::string classification_header_size = !has_classification ? "" : " 4";
  std::string classification_header_count = !has_classification ? "" : " 1";

  std::string gps_time_field = " gpstime";
  std::string gps_type_type = " F";
  std::string gps_type_size = " 8";
  std::string gps_type_count = " 1";

  std::ostringstream stream;
  stream << "# generated by Cartographer\n"
         << "VERSION .7\n"
         << "FIELDS x y z"  << color_header_field << classification_header_field << intensity_header_field << reflectivity_header_field << ambient_header_field << range_header_field << ring_header_field << gps_time_field << " frame" << "\n"
         << "SIZE 4 4 4"    << color_header_size  << classification_header_size << intensity_header_size  << reflectivity_header_size  << ambient_header_size  << range_header_size  << ring_header_size  << gps_time_size << " 4" << "\n"
         << "TYPE F F F"    << color_header_type  << classification_header_type << intensity_header_type  << reflectivity_header_type  << ambient_header_type  << range_header_type  << ring_header_type  << gps_time_type << " F"  << "\n"
         << "COUNT 1 1 1"   << color_header_count << classification_header_count << intensity_header_count << reflectivity_header_count << ambient_header_count << range_header_count << ring_header_count << gps_time_count << " 1" << "\n"
         << "WIDTH " << num_points << "\n"
         << "HEIGHT 1\n"
         << "VIEWPOINT 0 0 0 1 0 0 0\n"
         << "POINTS " << num_points
         << "\n"
         << "DATA ascii\n";
  const std::string out = stream.str();
  file_writer->WriteHeader(out.data(), out.size());
}

}  // namespace

std::unique_ptr<PcdAsciiIntensityWritingPointsProcessor>
PcdAsciiIntensityWritingPointsProcessor::FromDictionary(
    FileWriterFactory file_writer_factory,
    common::LuaParameterDictionary* const dictionary,
    PointsProcessor* const next) {
  return absl::make_unique<PcdAsciiIntensityWritingPointsProcessor>(
      file_writer_factory(dictionary->GetString("filename")), dictionary->GetString("export_fields"), next);
}

PcdAsciiIntensityWritingPointsProcessor::PcdAsciiIntensityWritingPointsProcessor(
    std::unique_ptr<FileWriter> file_writer, std::string export_fields, PointsProcessor* const next)
    : next_(next),
      num_points_(0),
      has_colors_(false),
      has_intensity_(false),
      has_reflectivity_(false),
      has_ambient_(false),
      has_range_(false),
      has_ring_(false),
      has_classification_(false),
      export_fields_(export_fields),
      file_writer_(std::move(file_writer)) {
        if (!export_fields_.empty()) {
          export_reflectivity_ = export_fields_.find("reflectivity") != std::string::npos;
          export_ambient_ = export_fields_.find("ambient") != std::string::npos;
          export_range_ = export_fields_.find("range") != std::string::npos;
          export_ring_ = export_fields_.find("ring") != std::string::npos;
          export_classification_ = export_fields_.find("classification") != std::string::npos;
        } else {
          export_reflectivity_ = true;
          export_ambient_ = true;
          export_range_ = true;
          export_ring_ = true;
          export_classification_ = true;
        }
      }

PointsProcessor::FlushResult PcdAsciiIntensityWritingPointsProcessor::Flush() {
  WriteBinaryPcdIntensityHeader(
    has_colors_,
    has_intensity_,
    has_reflectivity_ && export_reflectivity_,
    has_ambient_ && export_ambient_,
    has_range_ && export_range_,
    has_ring_ && export_ring_,
    has_classification_ && export_classification_,
    num_points_,
    file_writer_.get()
  );
  CHECK(file_writer_->Close());

  switch (next_->Flush()) {
    case FlushResult::kFinished:
      return FlushResult::kFinished;

    case FlushResult::kRestartStream:
      LOG(FATAL) << "PCD generation must be configured to occur after any "
                    "stages that require multiple passes.";
  }
  LOG(FATAL);
}

void PcdAsciiIntensityWritingPointsProcessor::Process(std::unique_ptr<PointsBatch> batch) {
  if (batch->points.empty()) {
    next_->Process(std::move(batch));
    return;
  }

  auto it = std::find(registered_frame_ids_.begin(), registered_frame_ids_.end(), batch->frame_id);
  if (it == registered_frame_ids_.end()) {
    registered_frame_ids_.push_back(batch->frame_id);
    it = std::find(registered_frame_ids_.begin(), registered_frame_ids_.end(), batch->frame_id);
  }
  float internal_frame_id = static_cast<float>(it - registered_frame_ids_.begin());

  if (num_points_ == 0) {
    has_colors_ = !batch->colors.empty();
    has_intensity_ = !batch->intensities.empty();
    has_reflectivity_ = !batch->reflectivities.empty();
    has_ambient_ = !batch->ambients.empty();
    has_range_ = !batch->ranges.empty();
    has_ring_ = !batch->rings.empty();
    has_classification_ = !batch->classifications.empty();
    WriteBinaryPcdIntensityHeader(
       has_colors_,
       has_intensity_,
       has_reflectivity_ && export_reflectivity_,
       has_ambient_ && export_ambient_,
       has_range_ && export_range_,
       has_ring_ && export_ring_,
       has_classification_ && export_classification_,
       0,
       file_writer_.get());
  }

  std::vector<uint32_t> range_values = batch->ranges;
  Eigen::Matrix<uint32_t, Eigen::Dynamic, 1> eigen_range_values = Eigen::Map<Eigen::Matrix<uint32_t, Eigen::Dynamic, 1>, Eigen::Unaligned>(range_values.data(), range_values.size());
  Eigen::VectorXf float_eigen_range_values = eigen_range_values.cast <float> ();

  for (size_t i = 0; i < batch->points.size(); ++i) {
    std::ostringstream stream;
    stream << batch->points[i].position[0] << " " << batch->points[i].position[1] << " " << batch->points[i].position[2];
    //  color_header_field <<
    if (!batch->colors.empty()) {
      cartographer::io::Uint8ColorWithAlpha uint8_color = ToUint8Color(batch->colors[i]);
      std::uint32_t color =  ((std::uint32_t)uint8_color[0] << 16 | (std::uint32_t)uint8_color[1] << 8 | (std::uint32_t)uint8_color[2]);
      float c = *reinterpret_cast<float*>(&color);;
      stream << " " << c << " " << static_cast<float>(uint8_color[0]) << " " << static_cast<float>(uint8_color[1]) << " " << static_cast<float>(uint8_color[2]);
    }
    if (!batch->classifications.empty()) {
      stream << " " << batch->classifications[i];
    }
    // intensity_header_field <<
    if (!batch->intensities.empty()) {
      stream << " " << batch->intensities[i];
    }
    // reflectivity_header_field <<
    if (!batch->reflectivities.empty() && export_reflectivity_) {
      stream << " " << static_cast<float>(batch->reflectivities[i]);
    }
    // ambient_header_field <<
    if (!batch->ambients.empty() && export_ambient_) {
      stream << " " << static_cast<float>(batch->ambients[i]);
    }
    // range_header_field <<
    if (!batch->ranges.empty() && export_range_) {
      stream << " " << float_eigen_range_values[i];
    }
    //  ring_header_field <<
    if (!batch->rings.empty() && export_ring_) {
      stream << " " << static_cast<float>(batch->rings[i]);
    }
    // gpstime
    stream << " " << cartographer::common::ToUniversal(batch->start_time);
    // " frame" << "\n"
    stream << " " << (float)internal_frame_id;
    stream << "\n";
    const std::string out = stream.str();
    file_writer_->Write(out.data(), out.size());
    ++num_points_;
  }
  next_->Process(std::move(batch));
}

}  // namespace io
}  // namespace cartographer
